use std::collections::{BinaryHeap, HashMap, HashSet, VecDeque};

fn main() {
    let input = std::fs::read_to_string("input.txt").unwrap();

    println!("Part 1: {}", part1(&input));
}

type NumPad = [[char; 3]; 4];
type DirPad = [[char; 3]; 2];
type Pos = (i32, i32);
type Dir = (i32, i32);

const DIRS: [Dir; 4] = [(1, 0), (-1, 0), (0, 1), (0, -1)];

fn part1(input: &str) -> usize {
    let codes = extract_codes(input);
    let num_pad: NumPad = [
        ['7', '8', '9'],
        ['4', '5', '6'],
        ['1', '2', '3'],
        ['\0', '0', 'A'],
    ];
    let dir_pad: DirPad = [['\0', '^', 'A'], ['<', 'v', '>']];

    let paths = shortest_paths(&num_pad, (2, 3), codes[0]);

    println!("{:?}", paths);
    0
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
struct State {
    pos: Pos,
    dir: Dir,
    steps: usize,
}

fn shortest_paths(num_pad: &[[char; 3]; 4], start: Pos, code: &str) -> Vec<Vec<char>> {
    let mut queue: VecDeque<(Pos, Vec<(Pos, Dir)>)> = VecDeque::from([(start, vec![])]);
    let end = code.chars().next().unwrap();

    let mut paths: Vec<Vec<Dir>> = vec![];

    while let Some((curr, dirs)) = queue.pop_front() {
        if get(num_pad, curr) == Some(end) {
           paths.
        }
    }

    vec![]
}

fn get(num_pad: &NumPad, pos: Pos) -> Option<char> {
    num_pad
        .get(pos.1 as usize)
        .and_then(|l| l.get(pos.0 as usize))
        .copied()
}

fn extract_codes(input: &str) -> Vec<&str> {
    input.lines().collect()
}
